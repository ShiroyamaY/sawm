# Лабораторная работа №5. Контроль доступа к веб‑приложению (Django)

## Цель работы
Продемонстрировать полный цикл внедрения контроля доступа в мини‑приложение из лабораторной №2: показать исходную уязвимость, настроить аутентификацию на основе сессий, разделить рабочие пространства по ролям «администратор» и «менеджер», а также доказать, что без успешного входа ни одна защищённая страница недоступна.

## Используемый стек
- Python 3.13 + Django 5.2.7 (структура проекта `guestbook`).
- SQLite 3 как встроенная БД.
- `uv` для управления виртуальной средой и зависимостями.
- Bootstrap‑подобная вёрстка на собственном CSS (`static/css/base.css`).

## Структура проекта
- `guestbook/` — корневые настройки, маршруты, конфигурация шаблонов и статики.
- `users/` — кастомная модель пользователя с полем `role`, вьюха входа, logout и management‑команда `seed_lab05`.
- `portals/` — рабочие пространства и CRUD для менеджера (`CustomerAccount`), а также административная панель.
- `guests/` — гостевая книга из лабораторной №2 (вариант с XSS и исправленный вариант для контраста).
- `templates/` и `static/` — общие шаблоны, базовый макет и стили.

## Подготовка окружения
1. Создаём и активируем виртуальную среду, устанавливаем зависимости:
   ```powershell
   uv venv
   .\.venv\Scripts\Activate.ps1
   uv pip install -r requirements.txt
   ```
2. Применяем миграции и наполняем БД демонстрационными учётками:
   ```powershell
   python manage.py migrate
   python manage.py seed_lab05
   ```
   После команды появятся пользователи `admin/Admin!123` и `manager/Manager!123`, а также несколько клиентских записей.
3. Запускаем приложение:
   ```powershell
   python manage.py runserver
   ```

## Ход работы
### Шаг 1. Базовое приложение из ЛР2 и демонстрация уязвимости
Мы перенесли гостевую книгу из `lab02` и оставили маршрут `/vulnerable/`, где данные выводятся через `{{ ...|safe }}` и отсутствует проверка сессии. Демонстрируем преподавателю, что зная URL `/admin/panel/` в исходной версии можно было зайти в панель без входа.

### Шаг 2. Сессии и настройка аутентификации
Подключили стандартные middleware Django (sessions + auth), создали собственную модель `users.User` с полем `role` и настроили `LoginView`. После успешной аутентификации мы читаем роль пользователя и перенаправляем в нужное рабочее пространство. Все закрытые контроллеры обёрнуты в `LoginRequiredMixin`.

### Шаг 3. Добавление роли «менеджер»
В таблице `users_user` появилось поле `role` с двумя значениями: `admin` и `manager`. Через `seed_lab05` создаём готовые аккаунты. Менеджер не имеет административных прав, но получает доступ к собственной зоне `/manager/...`.

### Шаг 4. Расширение БД и объектов предметной области
Добавлен `CustomerAccount` (модель приложения `portals`) со статусом, балансом и заметкой. Эти данные менеджер может просматривать, изменять и удалять. Администратор получает только режим обзора последних изменений.

### Шаг 5. Реализация рабочей зоны менеджера
Созданы представления:
- `/manager/workspace/` — дашборд с показателями.
- `/manager/accounts/` — список клиентов.
- `/manager/accounts/<id>/edit` и `/delete` — две ключевые функции: изменение данных и удаление записи.
- `/manager/accounts/create/` — вспомогательная функция для быстрого наполнения.
Все маршруты защищены миксином `RoleRequiredMixin` и доступны только роли `manager`.

### Шаг 6. Панель администратора
На `/admin/panel/` администратор видит список пользователей, их роли и последние действия менеджера (по факту — изменения клиентских записей). Без сессии маршрут сразу редиректит на `/auth/login/`, что демонстрирует устранение исходной проблемы.

### Шаг 7. Выход из системы
На обеих защищённых страницах есть кнопка «Выход», вызывающая `users.logout_view`, которая очищает сессию и возвращает пользователя на форму входа. Повторный вход обязателен.

## Сценарий демонстрации преподавателю
1. **Показ уязвимости**: открываем `/vulnerable/`, вводим `<script>alert('xss')</script>` и видим выполнение скрипта. Далее пробуем перейти на `/admin/panel/` без входа — получаем 302 на `/auth/login/`, фиксируя, что после внедрения сессий обход уже невозможен.
2. **Роль администратора**:
   - Входим под `admin/Admin!123`.
   - Сразу попадаем на `/admin/panel/`, видим список пользователей и свежие клиентские записи.
   - Проверяем, что URL менеджера (`/manager/accounts/`) выдаёт 403.
   - Нажимаем «Выход» и убеждаемся, что сессия очищена.
3. **Роль менеджера**:
   - Входим как `manager/Manager!123`, автоматически перенаправляемся на `/manager/workspace/`.
   - Открываем список клиентов, редактируем баланс одной записи и удаляем другую.
   - Проверяем, что попытка открыть `/admin/panel/` приводит к 403.
   - Завершаем работу через «Выход».

## Проверка контроля доступа
- Анонимный пользователь при обращении к `/admin/panel/` или `/manager/...` всегда получает редирект на `/auth/login/` благодаря `LoginRequiredMixin`.
- Пользователь с ролью `manager` не может попасть в административное пространство (исключение `PermissionDenied`).
- Администратор не имеет доступа к менеджерским CRUD и видит только защитный экран.
- Уязвимая форма `/vulnerable/` оставлена в учебных целях и подчёркнута в README, а безопасная версия `/` демонстрирует валидацию, работу CSRF и автоэкранирование.

## Команды для проверки
```powershell
python manage.py check          # Быстрая проверка настроек
python manage.py test           # Убеждаемся, что проект стартует без ошибок (тестов нет, но импорт проходит)
python manage.py seed_lab05     # Повторное наполнение ролей/данных при необходимости
python manage.py runserver      # Запуск сервера для демонстрации
```

## Итоги
Мы наглядно показали исходную проблему «доступ по знанию URL», внедрили сессионную аутентификацию, добавили ролевую модель (администратор + менеджер) и построили два изолированных рабочих пространства. Контроль доступа реализован на уровне вьюх и маршрутов, сценарий для преподавателя расписан по шагам, что позволяет быстро воспроизвести весь цикл событий для обеих ролей.
