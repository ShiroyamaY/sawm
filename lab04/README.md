# Лабораторная №4 — Защита конфиденциальных данных (пароли)

## Запуск
1. Установите/активируйте окружение uv:
   - Windows PowerShell:
     ```bash
     uv venv
     .\.venv\Scripts\Activate.ps1
     uv pip install django
     ```
2. Миграции и запуск:
   ```bash
   python manage.py migrate
   python manage.py runserver
   ```

## Страницы
- Безопасная гостевая: `/` — экранирование вывода, валидация, строгая CSP.
- Уязвимая гостевая (демо XSS): `/vulnerable/` — преднамеренно небезопасный вывод.
- Таблица `user` и регистрация: `/users/`, `/register/plain/`, `/register/hashed/`.

## Демонстрация XSS (из ЛР‑3, сохранено для полноты)
На странице `/vulnerable/` введите в поле «Сообщение» любой из вариантов:
- `<script>location.href='https://example.com'</script>` — редирект.
- `<img src=x onerror=alert('XSS')>` — выполнение JS при ошибке загрузки.

На странице `/` те же payload‑ы выводятся как текст (не выполняются).

## Что сделано против XSS
- По умолчанию Django экранирует `{{ переменные }}` в шаблонах.
- Удалён небезопасный фильтр `|safe` в «безопасной» версии.
- Серверная валидация email и обязательных полей.
- CSP для безопасной страницы: `default-src 'self'` (без `'unsafe-inline'`).

## Модели
- `guests.models.Guest(user, e_mail, text_message, data_time_message)` — записи гостевой.
- `guests.models.LabUser(username, password, is_hashed, created_at)` — учебная модель, хранится в таблице `user` (требование ЛР‑4).

## Эндпоинты для ЛР‑4
- `/register/plain/` — регистрируем пользователя без хеширования. Пароль сохраняется в открытом виде (демонстрация уязвимости).
- `/register/hashed/` — регистрируем пользователя с хешированием. Используется стандартный механизм Django `make_password` (PBKDF2 + соль).
- `/users/` — выводим содержимое таблицы `user` (логины и то, как пароли хранятся).

## Объяснения

Мы добавили три эндпоинта, чтобы наглядно показать разницу между хранением паролей в открытом виде и безопасным хранением с хешированием и солью.

1) Почему хранить пароли в открытом виде нельзя
- Если база утечёт, злоумышленник сразу видит все пароли и может переиспользовать их на других сайтах (частая привычка пользователей — одинаковые пароли).
- Администраторы БД получают доступ к приватным данным пользователей, это нарушает конфиденциальность и требования комплаенса.

2) Как рекомендуется формировать и хранить пароли
- Мы никогда не храним пароль в открытом виде. Мы хранim только криптографический хеш.
- Мы используем замедлённые функции хеширования, адаптированные под пароли: PBKDF2, bcrypt, scrypt, Argon2. В Django по умолчанию — PBKDF2 с солью и параметром итераций.
- Мы добавляем уникальную соль для каждого пароля. Соль предотвращает радужные таблицы и делает одинаковые пароли разными в БД.
- Мы выбираем достаточно длинные и случайные пароли: минимум 12–14 символов, смесь строчных/заглавных, цифр и символов, либо удобные «пассфразы» из нескольких слов.

Примеры паролей:
- Уязвимые: `123456`, `qwerty`, `Password1`, `iloveyou`, `admin123`.
- Надёжные: `rL9v!2xmN#pQ7z` или пассфраза вида `мороз-лист-железо-78`.

3) Почему MD5 и SHA‑1 считаются уязвимыми
- Эти функции быстрые и общецелевого назначения. На современных GPU/ASIC их можно перебирать миллиарды хешей в секунду.
- Для MD5 и SHA‑1 существуют эффективные коллизии; главное для паролей — скорость делает брутфорс и словарные атаки крайне доступными.
- Если пароли «захэшированы» с помощью MD5/SHA‑1 без соли, они уязвимы к радужным таблицам и мгновенной проверке по предрасчитанным базам.

Какие атаки возможны на MD5‑хеши паролей:
- Прямой брутфорс/словарь с GPU (очень быстро).
- Поиск в радужных таблицах/онлайн‑базах хешей.
- Сравнение частых шаблонов (например, `password`, `123456`) с добавлением типичных вариаций.

4) Что мы применили и почему
- Мы используем `django.contrib.auth.hashers.make_password`, который по умолчанию применяет PBKDF2 с солью и достаточным числом итераций. Это замедляет подбор пароля и для каждого пользователя создаёт уникальную соль.
- Мы можем переключиться на `Argon2` (рекомендуется сегодня) установив пакет `argon2-cffi` и настроив `PASSWORD_HASHERS` в `settings.py`. PBKDF2 уже достаточно надёжна и доступна «из коробки» в Django.

5) Как пароли хранятся в базе
- На странице `/users/` мы можем посмотреть поле `password`. Для незахешированной регистрации там будет виден открытый пароль — это демонстрация уязвимости.
- Для хешированной регистрации строка будет вида `pbkdf2_sha256$<iterations>$<salt>$<hash>`. Мы не можем восстановить исходный пароль из этой строки, мы лишь сверяем ввод пользователя, прогоняя его через тот же алгоритм.

6) Преимущество «скрытого» хранения и роль соли
- Преимущество: даже при утечке базы атакующему придётся дорого подбирать каждый пароль, а одинаковые пароли разных пользователей не совпадут по значению хеша.
- Соль: уникальное случайное значение, добавляемое к каждому паролю перед хешированием. Она ломает радужные таблицы и делает невозможным массовое сравнение одинаковых паролей.

## Как проверить ЛР‑4
1. Применяем миграции: `python manage.py migrate` (создаст таблицу `user`).
2. Открываем `/register/plain/`, создаём пользователя — увидим пароль в открытом виде на `/users/`.
3. Открываем `/register/hashed/`, создаём пользователя — увидим безопасный формат хеша с солью на `/users/`.
4. Сравниваем разницу и объясняем преподавателю, почему хранить «как есть» нельзя.




